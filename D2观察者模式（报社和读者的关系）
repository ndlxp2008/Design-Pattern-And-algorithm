抽象/封装/继承/多态

多用组合，少用继承

封装变化

为了交互对象的松耦合设计而努力

 1.标识耦合： 实体A 知道 实体B的存在，但不知道实体B怎么使用（即不会调用实体B的任何方法）
 在这种耦合情况下，实体B如果被删除掉，会影响实体A的编译，但是修改实体B的方法或实现，对实体A没有影响。
   标示耦合是最基本的耦合，大量存在系统中。
   可以通过组合的方式，比如实体有变量包含实体B或者实体B的集合。
   实际场景：订单子项表中关联产品实体表，表示该订单子项对应相应的商品。

2.表示耦合： 实体A 除了知道实体B存在，还调用了实体B的方法。
   在这种情况下，实体B的接口如果修改，比如更名、增减参数，会影响实体A的编译。这时就是表示耦合。
   表示耦合比较常见，好坏视同实际场景。
 实际场景：订单子项表调用了ProductPo的getPrice（获取价格）来计算该项目的总价。
3.子类耦合：实体A 调用 接口B 的方法来完成某项工作，实体A 的调用范围限定在接口B提供的方法，
至于它的子类怎么实现的实体A不关心（应该是第三方工厂类C关注的），但是实体A 对接口B的
实例进行强制转型，转为子类D，这样实体A就可以调用子类D的非接口方法，那实体A就和子类D
产生了耦合。
  子类耦合是不好的耦合。
4.继承耦合：实体A 继承实体B，通过继承获得实体B的保护级别或以上的方法。
   继承耦合一般情况下是好的耦合，有利于减少冗余，但是但继承深度不断变化时，
  会出现一些父类方法并不是子类需要的，而且如果使用了模板模式方法时，子类还被迫实现
  自己不需要的抽象方法（UnsupportedMethodException），那就成了不好的耦合了。  
  使用场景，一般在框架内，比如一些公共方法（增删改查）可以在抽象类中实现。
5.要避免的耦合 —— 双向耦合
双向耦合表示两个实体之间均至少存在标识耦合。
这样删除任一实体时，另一个实体将无法编译通过。
一般情况下这种耦合是不好的，意外耦合大多数场景都是这种双向耦合。

耦合：http://craft6.cn/detail/low_coupling.do




出版者+订阅者=观察者模式

出版者：Subject
订阅者：Observer

观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。





